package c;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Parser.grammar".
 */
public class Parser extends beaver.Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short INCR = 1;
		static public final short DECR = 2;
		static public final short STAR = 3;
		static public final short PLUS = 4;
		static public final short MINUS = 5;
		static public final short AMP = 6;
		static public final short ID = 7;
		static public final short LPAREN = 8;
		static public final short SIZEOF = 9;
		static public final short PREFIX = 10;
		static public final short POSTFIX = 11;
		static public final short NUM = 12;
		static public final short BANG = 13;
		static public final short TILDE = 14;
		static public final short ARROW = 15;
		static public final short DOT = 16;
		static public final short DIV = 17;
		static public final short MOD = 18;
		static public final short SHL = 19;
		static public final short SHR = 20;
		static public final short SEMICOLON = 21;
		static public final short LT = 22;
		static public final short LE = 23;
		static public final short GE = 24;
		static public final short GT = 25;
		static public final short EQ = 26;
		static public final short NEQ = 27;
		static public final short CARET = 28;
		static public final short PIPE = 29;
		static public final short ASG = 30;
		static public final short AND = 31;
		static public final short QUESTION = 32;
		static public final short OR = 33;
		static public final short ASG_OP = 34;
		static public final short STRUCT = 35;
		static public final short UNION = 36;
		static public final short ENUM = 37;
		static public final short UNSIGNED = 38;
		static public final short COMMA = 39;
		static public final short VOID = 40;
		static public final short SIGNED = 41;
		static public final short TYPE = 42;
		static public final short LBRACE = 43;
		static public final short RBRACE = 44;
		static public final short LBRACK = 45;
		static public final short RPAREN = 46;
		static public final short WHILE = 47;
		static public final short FOR = 48;
		static public final short DO = 49;
		static public final short IF = 50;
		static public final short RETURN = 51;
		static public final short BREAK = 52;
		static public final short CONTINUE = 53;
		static public final short TYPEDEF = 54;
		static public final short FIELD = 55;
		static public final short CHAR = 56;
		static public final short SHORT = 57;
		static public final short LONG = 58;
		static public final short INT = 59;
		static public final short ELSE = 60;
		static public final short RBRACK = 61;
		static public final short COLON = 62;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjMGbu5TKPFU#zl2LGGO5dG12aYX4IOYaARIeyYOGjXB0PK6jRkwcbrjOY5gnrmKgLpGt" +
		"PGKN13HK4DrHK11K4H12HHGHSMSMgK6czdhdplzao6P97yFFhbybtvjpv$tlFV#z$P#wTUG" +
		"4Im$0tZC2D#3l#WPlm5up1lt0v$eohS1rkm4$mKtH1T$HKXp03Fy0ng8zwIE37g8jEIE4S5" +
		"AC4fSZ13t4QZaKMwg0TZaT3jHinrdaEh#4bF8PxS3$cL2qIcZBISMY0HaZYLeoj95AsH8gh" +
		"NMYilimeKZwUmKmyo0YdOphkG1FVI2qbqYGKu6GCpIXIDYErO9oJS2fLckCKtqXjqv7K$z0" +
		"1Fwj697CKJ#DPFC58J#8ft8NEs8pj#CIHg$PMfBEjIFz5b2FB9D92YVGkyvYEj5jqiwr8hQ" +
		"ti5LKpafsz7p5I6#HX71x6UaRVOcMlAnwn8hrjHUg67kZbYMIhNM2rQ28jd7FH4MNeXm4u5" +
		"uDm7Yx4B$4xN8GX#0qkPZzwemzsuLA7Mg5B#KhqjTJwutQNyi00vN8CnZgSRobdOmELxyH3" +
		"BlMqsizn1dw1irpgPmQe$ufwlyPlgVwEwFrU#ds9h$uVTEaob$uV0$J$97V5fNXBwrs1OTG" +
		"VxT8UZcbQRoecusfSuzBU4Q1zBQx7IFoJsgDmCsx1U4oazcs#ytcAptpU7Q0zHUt4BCoMh1" +
		"lur3EV3s2kLZFmEEQvbEyBK6w31LY4vntABtYKNy4IItafNdKfFngW$3gMumsiSYY$wL7UY" +
		"FSivVUnpQNyGO3oH$YOQzDEX$8UAiztQSDIDW#dDWAqquUf3VqK5sAnZ$OcyjeCjUsZ4Ciy" +
		"skx3gRsYsjfLLLvvr9HN7pNbe4pxQHH#JpHgOYpVdGP4uyWKWdRFgksizje9dxMpOjHC#vj" +
		"PExkL$TRn8kiORntLQ$LoO2k$5ci2MsIQUUD8P$nUoJZK0KSs$fgnTgslrbVhg$KTBPztfu" +
		"3woiTsmB72MLPzJF2jxMSpVbqmZnPMAPVOYnFH32SWekrXqwvkvjcmjtBLDig6TQjkQTRu4" +
		"26sYY2BNw8nn97GNyPrzUyQzHm#8AdtX49#WoVvhTm5zTb3upU9XcY4a$cTqOhVyRtPxzPy" +
		"qo$dzwzHvtH#7xPZtzlpw#pCAaRATqHALHef8f7Yh6yWaqYvZ6H6oET#bkBNj5#af4JAerA" +
		"SNx2PH8f8pipU5bSIgSIA1FOcLOr8vYYAE8gkZDID#tQIN#qLSvMsT7H4wi3paKNAjNJpHJ" +
		"TYMU9Mf5Gr8zc#4iR8Gnz#YQMpcCvU2isjIAMEIC7PIxV8anREkKZoUSj1OpJXCzMKpyU9Z" +
		"D029w4bdyaIhTk7uxNLshgKS#ct#rRWKau5A1kwkHgcMeHjsp8VSPUwhPpKNvnEzUQ1wX69" +
		"aDPBIRzJbUWRfSxLwhqnBxcyAmozXDOlS6cd#9Pew0tacsBAaIL3EtuOxNHs4hfKL44xq$d" +
		"CvrzAtx#6ce6uPpwJqbC32K#lWvJpS1Rz2OToogESuFsPLZRwK5NbX9MFj7A1Hxb8LXS3#H" +
		"xblC1i93d#F8ToqfjffTBAIXzERLvLggtaCBN9njtYhrrABijCMrb7HMttKTLiLwBzVwmSb" +
		"6a$3RJzVcZKn5Y#EmrQJ8qZKwZQxXdiaxMJUXNMJf#nPzhVpDhPhHnl7QnZl7NKPAiZQL6j" +
		"pElnUjuhQSbtPAEWHcQrrbVhg$NL#chIvzafZ7NBpsQlSBPLLhOgAXXhiBInIyL4R$H0J$H" +
		"2NxrA3p3j6CIpQNVKrZLCQx6sc6LWttNcho7BYOQ4Cgz3vJmD9hACwpJOS8lpMjesyDeSll" +
		"DDZaxWgPdOEW3n$L9#ZBXQokDDZX$YQRIj4JfD$EC8er$pAecrbtMNckMidInVuVP7NwLjf" +
		"jHTABn4V6$JnxZH7K3uLF9#ylLaHVio87OC#IjoKt89kJLvChaZ6zCNAoONaGUGho9VH7w4" +
		"V3arBYPVGsQes6XoRpBRHjkHvv2Jv8Niyq7o4lBpv3LavYcsbSnvYEqXZo2pZw5Lp54shwV" +
		"POmktfCvaoTUrzES0aSybdwte7qbkJtwKt8NyEBcCl8by8NaBUGZR9CZ3oNN8eyZiGxYKPS" +
		"vVw1l9xMQMSscR9R7pxNvaDG8ICHRMfstwRaEudzJjpzCPZdwdxuyvSZrAU8ZmS1cJCNTTP" +
		"3ppQ5yW$Z6yNapU1ltVp33pZHd#zqTuel3zRBEIOwlFYxMYpt67nn9FqCUSH3gnF5VghwRj" +
		"KzgOd$W1yYIECKfUIjzyjkranmXDfwspbENP2jLrzoF478HVe4O3yil4HebJIAoWlHbv0$6" +
		"Ps3cVOUOyp3pYQ$91jruYM$AyKNYtt$ZzmBhh3bU7#lNSrnWQKFS4Vtie9cr773uUnlZOnW" +
		"RK$r9Yj11k8vmdd2yyI7Ymy2N2bmbVAJnI#4RXcuId24yJdYyizs98rfJG8k75mik5rmblz" +
		"nb3iLqExNAKln3#MlYGoU5ZXOyJRY3SK3XfQuHp777gYwsnjmzYD#wluntnTtZwURPFcmgs" +
		"oi2wVJtNvQ8hQmasL45ZgCbH6MkqmE6xmQU#h8jXcR$mLDiNxUwk6yhnj9tjtuT4gqhiUVx" +
		"sKA#ADkpZ4pZTWFh6O9QsgLlL3F9KDKLDLfFK13LHtQNkKBUhEzLjj8$NzSVeDWTr2ywN6g" +
		"UjezL$U1vhIgjzQh#wHNscfkchz$LvgrgcbkhIAmHt6iNLHprDF4KyIN0NKWi8heAAAvlYI" +
		"gkuKoZkqeexXvfBS5TJ3nCF4GyI3n3SnTHiWYkhkazwC5CjLw#hrrYQfQ#tAwxXwYNYHO9h" +
		"jk8QgBZNgUU8HSIpql8PoSOznDtgNhL3Zs#JUbVpnthqUzGxvFK4TswrZbXBlANRhT7dDqL" +
		"jkbfDh58VgG$L1uhhkFh4ygmq8ydr6$0ShB52xTNyESzV41lL1lNlz4oGtqlddxp5aV$Dng" +
		"w7ONmt2n5X6Ey50rWUH1JpdR87kGVjFMdloN8lefJNPUGo#al8VJGYw4VkHzz0rXt8yhb4D" +
		"w8xRKNqTsKvZVuQ4RuRPX46HucO0r4N6xzGdqCT4n5FEIg8ExYE$fNSZR0WItvRZpXibS5P" +
		"jwQHvT2FyjqtnBTV426MmxumtYlBNNw$kbaM1dyBFqP9yG==");

    Context context;

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] lst$global = global
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [1] lst$global = lst$global global
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [2] opt$lst$global = 
			Action.RETURN,	// [3] opt$lst$global = lst$global
			Action.RETURN,	// [4] unit = opt$lst$global
			new Action() {	// [5] field = type.t ID.n SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return new Field(t, n);
				}
			},
			new Action() {	// [6] lst$field = field
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [7] lst$field = lst$field field
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [8] opt$lst$field = 
			Action.RETURN,	// [9] opt$lst$field = lst$field
			Action.RETURN,	// [10] fields = opt$lst$field
			new Action() {	// [11] param = type.t ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return new Param(t, n);
				}
			},
			new Action() {	// [12] params = param
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [13] params = params COMMA param
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			Action.RETURN,	// [14] const = ID.n
			new Action() {	// [15] consts = const
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [16] consts = consts COMMA const
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [17] lst$stmt = stmt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [18] lst$stmt = lst$stmt stmt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [19] opt$lst$stmt = 
			Action.RETURN,	// [20] opt$lst$stmt = lst$stmt
			Action.RETURN,	// [21] stmts = opt$lst$stmt
			new Action() {	// [22] block0 = SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Block(new Stmt[]{});
				}
			},
			new Action() {	// [23] block1 = stmt.s SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new Block(new Stmt[]{s});
				}
			},
			new Action() {	// [24] block = LBRACE stmts.ss RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ss = _symbols[offset + 2];
					final ArrayList _list_ss = (ArrayList) _symbol_ss.value;
					final Stmt[] ss = _list_ss == null ? new Stmt[0] : (Stmt[]) _list_ss.toArray(new Stmt[_list_ss.size()]);
					 return new Block(ss);
				}
			},
			Action.RETURN,	// [25] blockn = block0
			Action.RETURN,	// [26] blockn = block1
			Action.RETURN,	// [27] blockn = block
			new Action() {	// [28] exprs = expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [29] exprs = exprs COMMA expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [30] global = TYPEDEF type.t ID.n SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 3];
					final String n = (String) _symbol_n.value;
					 return context.TypeDef(t, n);
				}
			},
			new Action() {	// [31] global = type.t ID.n SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return context.VarDef(t, n);
				}
			},
			new Action() {	// [32] global = type.t ID.n ASG expr.e SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					 return context.VarDef(t, n, e);
				}
			},
			new Action() {	// [33] global = STRUCT ID.n LBRACE fields.fs RBRACE SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_fs = _symbols[offset + 4];
					final ArrayList _list_fs = (ArrayList) _symbol_fs.value;
					final Field[] fs = _list_fs == null ? new Field[0] : (Field[]) _list_fs.toArray(new Field[_list_fs.size()]);
					 return context.StructDef(n, fs);
				}
			},
			new Action() {	// [34] global = UNION ID.n LBRACE fields.fs RBRACE SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_fs = _symbols[offset + 4];
					final ArrayList _list_fs = (ArrayList) _symbol_fs.value;
					final Field[] fs = _list_fs == null ? new Field[0] : (Field[]) _list_fs.toArray(new Field[_list_fs.size()]);
					 return context.UnionDef(n, fs);
				}
			},
			new Action() {	// [35] global = ENUM ID.n LBRACE consts.cs RBRACE SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_cs = _symbols[offset + 4];
					final ArrayList _list_cs = (ArrayList) _symbol_cs.value;
					final String[] cs = _list_cs == null ? new String[0] : (String[]) _list_cs.toArray(new String[_list_cs.size()]);
					 return context.EnumDef(n, cs);
				}
			},
			new Action() {	// [36] global = type.t ID.n LPAREN RPAREN SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return context.FunDef(t, n, new Param[]{});
				}
			},
			new Action() {	// [37] global = type.t ID.n LPAREN params.ps RPAREN SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_ps = _symbols[offset + 4];
					final ArrayList _list_ps = (ArrayList) _symbol_ps.value;
					final Param[] ps = _list_ps == null ? new Param[0] : (Param[]) _list_ps.toArray(new Param[_list_ps.size()]);
					 return context.FunDef(t, n, ps);
				}
			},
			new Action() {	// [38] global = type.t ID.n LPAREN RPAREN block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return context.FunDef(t, n, new Param[]{}, b);
				}
			},
			new Action() {	// [39] global = type.t ID.n LPAREN params.ps RPAREN block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_ps = _symbols[offset + 4];
					final ArrayList _list_ps = (ArrayList) _symbol_ps.value;
					final Param[] ps = _list_ps == null ? new Param[0] : (Param[]) _list_ps.toArray(new Param[_list_ps.size()]);
					final Symbol _symbol_b = _symbols[offset + 6];
					final Block b = (Block) _symbol_b.value;
					 return context.FunDef(t, n, ps, b);
				}
			},
			Action.RETURN,	// [40] stmt = SEMICOLON
			new Action() {	// [41] stmt = expr.a SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new Atomic(a);
				}
			},
			new Action() {	// [42] stmt = RETURN SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Return.self();
				}
			},
			new Action() {	// [43] stmt = RETURN expr.a SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new Return(a);
				}
			},
			new Action() {	// [44] stmt = BREAK SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Break.self();
				}
			},
			new Action() {	// [45] stmt = CONTINUE SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Return.self();
				}
			},
			new Action() {	// [46] stmt = type.t ID.n SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return new VarDef(t, n);
				}
			},
			new Action() {	// [47] stmt = type.t ID.n ASG expr.e SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					 return new VarDef(t, n, e);
				}
			},
			new Action() {	// [48] stmt = IF LPAREN expr.a RPAREN blockn.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new If(a, b);
				}
			},
			new Action() {	// [49] stmt = IF LPAREN expr.a RPAREN blockn.b ELSE blockn.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 7];
					final Block c = (Block) _symbol_c.value;
					 return new If(a, b, c);
				}
			},
			new Action() {	// [50] stmt = WHILE LPAREN expr.a RPAREN blockn.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new While(a, b);
				}
			},
			new Action() {	// [51] stmt = DO blockn.b WHILE LPAREN expr.a RPAREN SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_a = _symbols[offset + 5];
					final Expr a = (Expr) _symbol_a.value;
					 return new DoWhile(b, a);
				}
			},
			new Action() {	// [52] stmt = FOR LPAREN expr.a SEMICOLON expr.b SEMICOLON expr.c SEMICOLON RPAREN blockn.p
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Expr b = (Expr) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 7];
					final Expr c = (Expr) _symbol_c.value;
					final Symbol _symbol_p = _symbols[offset + 10];
					final Block p = (Block) _symbol_p.value;
					 return new For(a, b, c, p);
				}
			},
			Action.RETURN,	// [53] expr = PREFIX
			Action.RETURN,	// [54] expr = POSTFIX
			new Action() {	// [55] expr = ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return new Id(n);
				}
			},
			new Action() {	// [56] expr = NUM.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Long n = (Long) _symbol_n.value;
					 return new Lit(n);
				}
			},
			new Action() {	// [57] expr = expr.a INCR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new PostOp("++", a);
				}
			},
			new Action() {	// [58] expr = expr.a DECR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new PostOp("--", a);
				}
			},
			new Action() {	// [59] expr = expr.a LBRACK expr.i RBRACK
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_i = _symbols[offset + 3];
					final Expr i = (Expr) _symbol_i.value;
					 return new Index(a, i);
				}
			},
			new Action() {	// [60] expr = expr.a ARROW FIELD.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final String f = (String) _symbol_f.value;
					 return new Lookup(a, f);
				}
			},
			new Action() {	// [61] expr = expr.a DOT FIELD.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final String f = (String) _symbol_f.value;
					 return new Lookup(new PreOp("&", a), f);
				}
			},
			new Action() {	// [62] expr = INCR expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("++", a);
				}
			},
			new Action() {	// [63] expr = DECR expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("--", a);
				}
			},
			new Action() {	// [64] expr = PLUS expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("+", a);
				}
			},
			new Action() {	// [65] expr = MINUS expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("-", a);
				}
			},
			new Action() {	// [66] expr = BANG expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("!", a);
				}
			},
			new Action() {	// [67] expr = TILDE expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("~", a);
				}
			},
			new Action() {	// [68] expr = STAR expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("*", a);
				}
			},
			new Action() {	// [69] expr = AMP expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new PreOp("&", a);
				}
			},
			new Action() {	// [70] expr = SIZEOF LPAREN expr.e RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 return new SizeOfExpr(e);
				}
			},
			new Action() {	// [71] expr = expr.a STAR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("*", a, b);
				}
			},
			new Action() {	// [72] expr = expr.a DIV expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("/", a, b);
				}
			},
			new Action() {	// [73] expr = expr.a MOD expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("%", a, b);
				}
			},
			new Action() {	// [74] expr = expr.a PLUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("+", a, b);
				}
			},
			new Action() {	// [75] expr = expr.a MINUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("-", a, b);
				}
			},
			new Action() {	// [76] expr = expr.a SHL expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("<<",a, b);
				}
			},
			new Action() {	// [77] expr = expr.a SHR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp(">>",a, b);
				}
			},
			new Action() {	// [78] expr = expr.a LT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("<", a, b);
				}
			},
			new Action() {	// [79] expr = expr.a LE expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("<=",a, b);
				}
			},
			new Action() {	// [80] expr = expr.a GE expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp(">=",a, b);
				}
			},
			new Action() {	// [81] expr = expr.a GT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp(">", a, b);
				}
			},
			new Action() {	// [82] expr = expr.a EQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("==",a, b);
				}
			},
			new Action() {	// [83] expr = expr.a NEQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("~=",a, b);
				}
			},
			new Action() {	// [84] expr = expr.a AMP expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("&", a, b);
				}
			},
			new Action() {	// [85] expr = expr.a CARET expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("^", a, b);
				}
			},
			new Action() {	// [86] expr = expr.a PIPE expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("|", a, b);
				}
			},
			new Action() {	// [87] expr = expr.a AND expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("&&",a, b);
				}
			},
			new Action() {	// [88] expr = expr.a OR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("||",a, b);
				}
			},
			new Action() {	// [89] expr = expr.a ASG expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp("=", a, b);
				}
			},
			new Action() {	// [90] expr = expr.a ASG_OP.e expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final String e = (String) _symbol_e.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp(e, a, b);
				}
			},
			new Action() {	// [91] expr = expr.a COMMA expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new BinOp(",", a, b);
				}
			},
			new Action() {	// [92] expr = ID.n LPAREN RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return new FunCall(n, new Expr[]{});
				}
			},
			new Action() {	// [93] expr = ID.n LPAREN exprs.as RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_as = _symbols[offset + 3];
					final ArrayList _list_as = (ArrayList) _symbol_as.value;
					final Expr[] as = _list_as == null ? new Expr[0] : (Expr[]) _list_as.toArray(new Expr[_list_as.size()]);
					 return new FunCall(n, as);
				}
			},
			new Action() {	// [94] expr = LPAREN type.t RPAREN expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final Expr a = (Expr) _symbol_a.value;
					 return new Cast(t, a);
				}
			},
			new Action() {	// [95] expr = LPAREN expr.e RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return (Symbol) e;
				}
			},
			new Action() {	// [96] expr = expr.a QUESTION expr.b COLON expr.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final Expr c = (Expr) _symbol_c.value;
					 return new Question(a, b, c);
				}
			},
			new Action() {	// [97] type = VOID
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return (Symbol) Void.self();
				}
			},
			Action.NONE,  	// [98] opt$SIGNED = 
			Action.RETURN,	// [99] opt$SIGNED = SIGNED
			new Action() {	// [100] type = opt$SIGNED CHAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return (Symbol) SChar.self();
				}
			},
			new Action() {	// [101] type = opt$SIGNED SHORT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return (Symbol) SShort.self();
				}
			},
			new Action() {	// [102] type = opt$SIGNED INT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return (Symbol) SInt.self();
				}
			},
			new Action() {	// [103] type = opt$SIGNED LONG
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return (Symbol) SLong.self();
				}
			},
			new Action() {	// [104] type = UNSIGNED CHAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return (Symbol) UChar.self();
				}
			},
			new Action() {	// [105] type = UNSIGNED SHORT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return (Symbol) UShort.self();
				}
			},
			Action.NONE,  	// [106] opt$INT = 
			Action.RETURN,	// [107] opt$INT = INT
			new Action() {	// [108] type = UNSIGNED opt$INT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return (Symbol) UInt.self();
				}
			},
			new Action() {	// [109] type = UNSIGNED LONG
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return (Symbol) ULong.self();
				}
			},
			new Action() {	// [110] type = TYPE.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final String t = (String) _symbol_t.value;
					 return new TypedefName(t);
				}
			},
			new Action() {	// [111] type = type.t STAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					 return new PtrType(t);
				}
			},
			new Action() {	// [112] type = STRUCT ID.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final String t = (String) _symbol_t.value;
					 return new StructName(t);
				}
			},
			new Action() {	// [113] type = UNION ID.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final String t = (String) _symbol_t.value;
					 return new UnionName(t);
				}
			},
			new Action() {	// [114] type = ENUM ID.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final String t = (String) _symbol_t.value;
					 return new EnumName(t);
				}
			},
			new Action() {	// [115] type = STRUCT LBRACE fields.fs RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_fs = _symbols[offset + 3];
					final ArrayList _list_fs = (ArrayList) _symbol_fs.value;
					final Field[] fs = _list_fs == null ? new Field[0] : (Field[]) _list_fs.toArray(new Field[_list_fs.size()]);
					 return new StructType(fs);
				}
			},
			new Action() {	// [116] type = UNION LBRACE fields.fs RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_fs = _symbols[offset + 3];
					final ArrayList _list_fs = (ArrayList) _symbol_fs.value;
					final Field[] fs = _list_fs == null ? new Field[0] : (Field[]) _list_fs.toArray(new Field[_list_fs.size()]);
					 return new UnionType(fs);
				}
			},
			new Action() {	// [117] type = ENUM LBRACE consts.cs RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_cs = _symbols[offset + 3];
					final ArrayList _list_cs = (ArrayList) _symbol_cs.value;
					final String[] cs = _list_cs == null ? new String[0] : (String[]) _list_cs.toArray(new String[_list_cs.size()]);
					 return new EnumType(cs);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
